<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      margin: 0; 
      padding: 20px;
      min-height: 100vh;
      background: rgb(50, 50, 50);
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #sketches {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 40px;
    }
    #sketch1, #sketch2 {
      position: relative;
    }
    canvas {
      border: 1px solid #333;
    }
    .controls {
      background: #e0e0e0;
      padding: 8px 15px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-top: 20px;
    }
    .randomizer-btn {
      background: #666;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: background 0.2s;
    }
    .randomizer-btn:hover {
      background: #777;
    }
    .color-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .color-label {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      text-transform: uppercase;
    }
    .color-swatch {
      position: relative;
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #999;
      padding: 0;
      cursor: pointer;
      overflow: hidden;
    }
    input[type="color"] {
      position: absolute;
      top: -2px;
      left: -2px;
      width: 24px;
      height: 24px;
      border: none;
      padding: 0;
      cursor: pointer;
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
    }
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .checkbox-label {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div id="sketches">
    <div id="sketch1"></div>
    <div id="sketch2"></div>
  </div>
  <div class="controls">
    <div class="checkbox-group">
      <input type="checkbox" id="diptychToggle">
      <label for="diptychToggle" class="checkbox-label">DIPTYCH</label>
    </div>
    <button class="randomizer-btn" onclick="regenerateAll()">RANDOMIZER</button>
    <div class="color-group">
      <span class="color-label">LEFT</span>
      <div class="color-swatch">
        <input type="color" id="colorA" value="#0A1019">
      </div>
    </div>
    <div class="color-group">
      <span class="color-label">RIGHT</span>
      <div class="color-swatch">
        <input type="color" id="colorB" value="#5B5448">
      </div>
    </div>
  </div>

  <script>
    let sketch1, sketch2;
    
    function createSketch(parent) {
      return new p5((p) => {
        const SCALE = 8;
        const CANVAS_WIDTH = 48;
        const CANVAS_HEIGHT = 60;
        const STRIP_WIDTHS = [4, 8, 12, 16, 20, 24];
        
        let rectangles = [];
        let colorA, colorB;
        
        p.setup = function() {
          p.createCanvas(CANVAS_WIDTH * SCALE, CANVAS_HEIGHT * SCALE);
          const initialColorA = p.color(10, 16, 25);
          const initialColorB = p.color(91, 84, 72);
          colorA = initialColorA;
          colorB = initialColorB;
          generateComposition();
        };
        
        function generateComposition() {
          rectangles = [];
          let currentY = 0;
          
          while (currentY < CANVAS_HEIGHT) {
            if (p.random() < 0.2 && currentY < CANVAS_HEIGHT - 5) {
              let height = Math.round(p.random(1, 5));
              let xOffset = (CANVAS_WIDTH - 36) / 2;
              
              rectangles.push({
                x: xOffset,
                y: currentY,
                width: 36,
                height: height,
                isFullWidth: false
              });
              
              if (xOffset > 0) {
                rectangles.push({
                  x: 0,
                  y: currentY,
                  width: xOffset,
                  height: height,
                  isFullWidth: false
                });
                
                rectangles.push({
                  x: xOffset + 36,
                  y: currentY,
                  width: xOffset,
                  height: height,
                  isFullWidth: false
                });
              }
              
              currentY += height;
              continue;
            }
            
            let remainingHeight = CANVAS_HEIGHT - currentY;
            let rowHeight = Math.min(
              remainingHeight,
              Math.max(4, Math.round(p.random() < 0.7 ? p.random(4, 8) : p.random(12, 16)) * 2) / 2
            );
            
            let currentX = 0;
            while (currentX < CANVAS_WIDTH) {
              let remainingWidth = CANVAS_WIDTH - currentX;
              let availableWidths = STRIP_WIDTHS.filter(w => w <= remainingWidth);
              
              if (availableWidths.length === 0) {
                rectangles.push({
                  x: currentX,
                  y: currentY,
                  width: remainingWidth,
                  height: rowHeight
                });
                break;
              }
              
              let width = biasedWidthSelection();
              while (width > remainingWidth) {
                width = biasedWidthSelection();
              }
              
              if (width >= 16 && p.random() < 0.2) {
                let numSections = 2;
                let subWidth = width / numSections;
                for (let i = 0; i < numSections; i++) {
                  rectangles.push({
                    x: currentX + (i * subWidth),
                    y: currentY,
                    width: subWidth,
                    height: rowHeight
                  });
                }
              } else {
                rectangles.push({
                  x: currentX,
                  y: currentY,
                  width: width,
                  height: rowHeight
                });
              }
              
              currentX += width;
            }
            
            currentY += rowHeight;
          }
          
          p.redraw();
        }
        
        function biasedWidthSelection() {
          const rand = p.random();
          if (rand < 0.4) {
            return STRIP_WIDTHS.slice(0, 2)[Math.floor(p.random(2))];
          } else if (rand < 0.7) {
            return STRIP_WIDTHS.slice(-2)[Math.floor(p.random(2))];
          } else {
            return STRIP_WIDTHS.slice(2, 4)[Math.floor(p.random(2))];
          }
        }
        
        p.draw = function() {
          p.background(255);
          
          rectangles.forEach(rect => {
            let x = rect.x * SCALE;
            let y = rect.y * SCALE;
            let w = rect.width * SCALE;
            let h = rect.height * SCALE;
            
            for (let i = 0; i < w; i++) {
              let inter = i / w;
              let c = p.lerpColor(colorA, colorB, inter);
              p.stroke(c);
              p.line(x + i, y, x + i, y + h);
            }
            
            p.stroke(0);
            p.noFill();
            p.rect(x, y, w, h);
          });
        };
        
        p.updateColors = function(color1, color2) {
          colorA = color1;
          colorB = color2;
          p.redraw();
        };
        
        p.regenerate = generateComposition;
        
      }, parent);
    }
    
    // Create both sketches
    sketch1 = createSketch('sketch1');
    sketch2 = createSketch('sketch2');
    
    // Initially hide second sketch
    document.getElementById('sketch2').style.display = 'none';
    
    // Handle diptych toggle
    document.getElementById('diptychToggle').addEventListener('change', function(e) {
      document.getElementById('sketch2').style.display = e.target.checked ? 'block' : 'none';
      if (e.target.checked) {
        sketch2.regenerate();
      }
    });
    
    // Handle color changes
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function updateColors(e) {
      const colorA = document.getElementById('colorA').value;
      const colorB = document.getElementById('colorB').value;
      
      // Convert hex to p5 color objects and update sketches
      if (sketch1 && sketch1._renderer) {
        const p5colorA1 = sketch1._renderer._pInst.color(colorA);
        const p5colorB1 = sketch1._renderer._pInst.color(colorB);
        sketch1.updateColors(p5colorA1, p5colorB1);
      }
      
      if (sketch2 && sketch2._renderer) {
        const p5colorA2 = sketch2._renderer._pInst.color(colorA);
        const p5colorB2 = sketch2._renderer._pInst.color(colorB);
        sketch2.updateColors(p5colorA2, p5colorB2);
      }
    }
    
    // Set initial colors (RGB: 10,16,25 and 91,84,72)
    const initialColorA = rgbToHex(10, 16, 25);
    const initialColorB = rgbToHex(91, 84, 72);
    
    // Set initial values for color inputs
    document.getElementById('colorA').value = initialColorA;
    document.getElementById('colorB').value = initialColorB;
    
    // Initial color update
    updateColors();
    
    // Add color change listeners
    document.getElementById('colorA').addEventListener('input', updateColors);
    document.getElementById('colorB').addEventListener('input', updateColors);
    
    // Function to regenerate both compositions
    function regenerateAll() {
      sketch1.regenerate();
      if (document.getElementById('diptychToggle').checked) {
        sketch2.regenerate();
      }
    }
  </script>
</body>
</html>
